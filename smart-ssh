#!/bin/bash

# smart-ssh - Local network-based SSH connection script
# Automatically chooses between regular public key auth (home) and security key auth (away)
# Usage: smart-ssh <hostname>
# Example: smart-ssh hostname

# Configuration file path (XDG Base Directory compliant)
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/smart-ssh"
CONFIG_FILE="$CONFIG_DIR/config"

# Default configuration values
DEFAULT_HOME_NETWORK="192.168.1.0/24"
DEFAULT_HOME_GATEWAY_MAC=""
DEFAULT_SECURITY_KEY_PATH="$HOME/.ssh/id_ed25519_sk"
DEFAULT_LOG_LEVEL="info"

# Load configuration from file if it exists
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Source the config file in a safe manner
        while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^#.*$ ]] && continue
            [[ -z "$key" ]] && continue

            # Remove leading/trailing whitespace
            key=$(echo "$key" | xargs)
            value=$(echo "$value" | xargs)

            # Remove quotes from value if present
            value="${value%\"}"
            value="${value#\"}"
            value="${value%\'}"
            value="${value#\'}"

            case "$key" in
                HOME_NETWORK)
                    CONFIG_HOME_NETWORK="$value"
                    ;;
                HOME_GATEWAY_MAC)
                    CONFIG_HOME_GATEWAY_MAC="$value"
                    ;;
                SECURITY_KEY_PATH)
                    CONFIG_SECURITY_KEY_PATH="$value"
                    ;;
                LOG_LEVEL)
                    CONFIG_LOG_LEVEL="$value"
                    ;;
            esac
        done < "$CONFIG_FILE"
    fi
}

# Load configuration
load_config

# Configuration priority: Environment variable > Config file > Default
# Home networks (can be overridden by environment variable, comma-separated)
HOME_NETWORK="${HOME_NETWORK:-${CONFIG_HOME_NETWORK:-$DEFAULT_HOME_NETWORK}}"
# Home gateway MAC addresses (can be overridden by environment variable, comma-separated)
HOME_GATEWAY_MAC="${HOME_GATEWAY_MAC:-${CONFIG_HOME_GATEWAY_MAC:-$DEFAULT_HOME_GATEWAY_MAC}}"
# Security key path (can be overridden by environment variable)
SECURITY_KEY_PATH="${SECURITY_KEY_PATH:-${CONFIG_SECURITY_KEY_PATH:-$DEFAULT_SECURITY_KEY_PATH}}"
# Expand ~ in SECURITY_KEY_PATH
SECURITY_KEY_PATH="${SECURITY_KEY_PATH/#\~/$HOME}"
# Log level
LOG_LEVEL="${LOG_LEVEL:-${CONFIG_LOG_LEVEL:-$DEFAULT_LOG_LEVEL}}"

# Color output support (respects NO_COLOR environment variable)
if [ -t 1 ] && [ -z "${NO_COLOR}" ]; then
    COLOR_RESET='\033[0m'
    COLOR_RED='\033[0;31m'
    COLOR_GREEN='\033[0;32m'
    COLOR_YELLOW='\033[0;33m'
    COLOR_BLUE='\033[0;34m'
    COLOR_CYAN='\033[0;36m'
else
    COLOR_RESET=''
    COLOR_RED=''
    COLOR_GREEN=''
    COLOR_YELLOW=''
    COLOR_BLUE=''
    COLOR_CYAN=''
fi

# Log level constants
LOG_LEVEL_DEBUG=0
LOG_LEVEL_INFO=1
LOG_LEVEL_WARN=2
LOG_LEVEL_ERROR=3

# Convert log level string to number
get_log_level_number() {
    local level_lower=$(echo "$LOG_LEVEL" | tr '[:upper:]' '[:lower:]')
    case "$level_lower" in
        debug) echo $LOG_LEVEL_DEBUG ;;
        info) echo $LOG_LEVEL_INFO ;;
        warn) echo $LOG_LEVEL_WARN ;;
        error) echo $LOG_LEVEL_ERROR ;;
        *) echo $LOG_LEVEL_INFO ;;
    esac
}

CURRENT_LOG_LEVEL=$(get_log_level_number)
# Ensure CURRENT_LOG_LEVEL is set (default to INFO if empty)
CURRENT_LOG_LEVEL=${CURRENT_LOG_LEVEL:-$LOG_LEVEL_INFO}

# Print functions for colored output
print_error() {
    echo -e "${COLOR_RED}$*${COLOR_RESET}" >&2
}

print_success() {
    echo -e "${COLOR_GREEN}$*${COLOR_RESET}"
}

print_warning() {
    echo -e "${COLOR_YELLOW}$*${COLOR_RESET}"
}

print_info() {
    echo -e "${COLOR_CYAN}$*${COLOR_RESET}"
}

print_debug() {
    echo -e "${COLOR_BLUE}$*${COLOR_RESET}"
}

# Logging functions with log level support
log_error() {
    if [ "$CURRENT_LOG_LEVEL" -le "$LOG_LEVEL_ERROR" ]; then
        print_error "[ERROR] $*"
    fi
}

log_warn() {
    if [ "$CURRENT_LOG_LEVEL" -le "$LOG_LEVEL_WARN" ]; then
        print_warning "[WARN] $*"
    fi
}

log_info() {
    if [ "$CURRENT_LOG_LEVEL" -le "$LOG_LEVEL_INFO" ]; then
        print_info "[INFO] $*"
    fi
}

log_debug() {
    if [ "$CURRENT_LOG_LEVEL" -le "$LOG_LEVEL_DEBUG" ]; then
        print_debug "[DEBUG] $*"
    fi
}

# Show usage information
usage() {
    echo "Usage: $0 [OPTIONS] <hostname> [SSH_OPTIONS]"
    echo ""
    echo "Examples:"
    echo "  $0 hostname"
    echo "  $0 production-server"
    echo "  $0 hostname -v                    # Pass -v to ssh for verbose output"
    echo "  $0 hostname -p 2222               # Use custom SSH port"
    echo "  $0 -- hostname -v -p 2222         # Use -- to separate options"
    echo "  HOME_GATEWAY_MAC=aa:bb:cc:dd:ee:ff $0 hostname  # Use MAC-based detection"
    echo "  HOME_NETWORK=192.168.1.0/24,10.0.0.0/24 $0 hostname"
    echo "  SECURITY_KEY_PATH=~/.ssh/id_ecdsa_sk $0 --security-key hostname"
    echo ""
    echo "Required SSH config pattern (~/.ssh/config):"
    echo "  Host <hostname>                # Single host entry"
    echo "                                 # Regular key specified in IdentityFile"
    echo "                                 # Security key used with -i when away"
    echo ""
    echo "Smart-SSH Options:"
    echo "  --security-key, -s   Force security key authentication"
    echo "  --dry-run, -n        Show what would be executed without connecting"
    echo "  --init-config        Create default configuration file"
    echo "  --debug, -d          Show debug information"
    echo "  --help, -h           Show this help message"
    echo "  --                   End of smart-ssh options (remaining args are SSH options)"
    echo ""
    echo "SSH Options:"
    echo "  Any SSH options (like -v, -p, -L, etc.) are passed through to ssh."
    echo "  Place them after the hostname or use -- to separate them clearly."
    echo ""
    echo "Configuration:"
    echo "  Config file: $CONFIG_FILE"
    echo "  Priority: Environment variable > Config file > Default"
    echo ""
    echo "Author: https://github.com/ngc-shj/smart-ssh"
}

# Initialize configuration file
init_config() {
    if [ -f "$CONFIG_FILE" ]; then
        print_warning "Configuration file already exists: $CONFIG_FILE"
        read -rp "Overwrite? (y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            return 1
        fi
    fi

    # Create config directory if it doesn't exist
    mkdir -p "$CONFIG_DIR"

    # Create default configuration file
    cat > "$CONFIG_FILE" <<'EOF'
# smart-ssh configuration file
# This file follows the format: KEY=value
# Lines starting with # are comments

# Home gateway MAC addresses (comma-separated, preferred detection method)
# Use 'smart-ssh --debug' to find your gateway MAC address
# Example: HOME_GATEWAY_MAC=aa:bb:cc:dd:ee:ff,11:22:33:44:55:66
HOME_GATEWAY_MAC=

# Home networks (comma-separated CIDR ranges, fallback detection method)
# Example: HOME_NETWORK=192.168.1.0/24,10.0.0.0/24,172.16.0.0/12
HOME_NETWORK=192.168.1.0/24

# Security key path
# Default: ~/.ssh/id_ed25519_sk
SECURITY_KEY_PATH=~/.ssh/id_ed25519_sk

# Log level (debug, info, warn, error)
# Default: info
LOG_LEVEL=info
EOF

    print_success "Configuration file created: $CONFIG_FILE"
    echo ""
    echo "Edit the file to customize your settings:"
    echo "  ${EDITOR:-vi} $CONFIG_FILE"
    return 0
}

# Validate IP address format
validate_ip() {
    local ip="$1"
    local valid_ip_regex='^([0-9]{1,3}\.){3}[0-9]{1,3}$'

    if ! [[ "$ip" =~ $valid_ip_regex ]]; then
        return 1
    fi

    # Check each octet is 0-255
    local -a octets
    IFS='.' read -ra octets <<< "$ip"
    for octet in "${octets[@]}"; do
        if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
            return 1
        fi
    done

    return 0
}

# Validate CIDR format
validate_cidr() {
    local cidr="$1"

    if [[ ! "$cidr" =~ ^[^/]+/[0-9]+$ ]]; then
        print_error "Error: Invalid CIDR format: $cidr"
        echo "Expected format: IP/MASK (e.g., 192.168.1.0/24)" >&2
        return 1
    fi

    local network=$(echo "$cidr" | cut -d'/' -f1)
    local mask_bits=$(echo "$cidr" | cut -d'/' -f2)

    # Validate IP address
    if ! validate_ip "$network"; then
        print_error "Error: Invalid IP address in CIDR: $network"
        return 1
    fi

    # Validate mask bits (0-32)
    if [ "$mask_bits" -lt 0 ] || [ "$mask_bits" -gt 32 ]; then
        print_error "Error: Invalid network mask bits: $mask_bits (must be 0-32)"
        return 1
    fi

    return 0
}

# Get gateway IP address
get_gateway_ip() {
    local gateway_ip=""

    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        gateway_ip=$(route -n get default 2>/dev/null | grep 'gateway:' | awk '{print $2}')
    elif command -v ip >/dev/null 2>&1; then
        # Linux with ip command
        gateway_ip=$(ip route show default 2>/dev/null | awk '/default/ {print $3}')
    elif command -v route >/dev/null 2>&1; then
        # Linux with route command
        gateway_ip=$(route -n 2>/dev/null | awk '/^0.0.0.0/ {print $2}')
    fi

    if [ -n "$gateway_ip" ]; then
        echo "$gateway_ip"
        return 0
    fi
    return 1
}

# Get gateway MAC address via ARP
get_gateway_mac() {
    local gateway_ip
    gateway_ip=$(get_gateway_ip)

    if [ -z "$gateway_ip" ]; then
        log_debug "Cannot determine gateway IP"
        return 1
    fi

    local mac=""

    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS: arp -n <ip> returns "? (192.168.1.1) at aa:bb:cc:dd:ee:ff on en0 ..."
        mac=$(arp -n "$gateway_ip" 2>/dev/null | awk '{print $4}')
    elif command -v ip >/dev/null 2>&1; then
        # Linux with ip command
        mac=$(ip neigh show "$gateway_ip" 2>/dev/null | awk '{print $5}')
    elif command -v arp >/dev/null 2>&1; then
        # Linux with arp command
        mac=$(arp -n "$gateway_ip" 2>/dev/null | awk 'NR>1 {print $3}')
    fi

    # Normalize MAC address to lowercase
    if [ -n "$mac" ] && [ "$mac" != "(incomplete)" ]; then
        echo "$mac" | tr '[:upper:]' '[:lower:]'
        return 0
    fi

    return 1
}

# Check if current gateway MAC matches any home gateway MAC
is_home_gateway_mac() {
    local current_mac="$1"

    if [ -z "$current_mac" ] || [ -z "$HOME_GATEWAY_MAC" ]; then
        return 1
    fi

    # Normalize current MAC to lowercase
    current_mac=$(echo "$current_mac" | tr '[:upper:]' '[:lower:]')

    # Split HOME_GATEWAY_MAC by comma and check each
    IFS=',' read -ra macs <<< "$HOME_GATEWAY_MAC"
    for mac in "${macs[@]}"; do
        # Trim whitespace and normalize to lowercase
        mac=$(echo "$mac" | xargs | tr '[:upper:]' '[:lower:]')
        if [ "$current_mac" = "$mac" ]; then
            return 0
        fi
    done
    return 1
}

# Get current local IP address
get_current_ip() {
    local ip
    
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS
        local default_interface=$(route get default 2>/dev/null | grep interface: | awk '{print $2}')
        if [ -n "$default_interface" ]; then
            ip=$(ifconfig "$default_interface" 2>/dev/null | grep 'inet ' | grep -v '127.0.0.1' | head -1 | awk '{print $2}')
        fi
    elif grep -qi "microsoft.*wsl\|wsl.*microsoft" /proc/version 2>/dev/null || command -v powershell.exe >/dev/null 2>&1; then
        # WSL2 - get Windows host WiFi IP (not WSL2 internal IP)
        ip=$(powershell.exe -Command "
            \$wifiAdapter = Get-NetAdapter | Where-Object {\$_.InterfaceDescription -like '*Wi-Fi*' -and \$_.Status -eq 'Up'}
            if (\$wifiAdapter) {
                \$ipConfig = Get-NetIPAddress -InterfaceIndex \$wifiAdapter.InterfaceIndex -AddressFamily IPv4 | Where-Object {\$_.AddressState -eq 'Preferred' -and \$_.IPAddress -notlike '169.254.*'}
                if (\$ipConfig) {
                    \$ipConfig.IPAddress
                } else {
                    'NOT_CONNECTED'
                }
            } else {
                'NOT_CONNECTED'
            }
        " 2>/dev/null | tr -d '\r\n')
    elif command -v ip >/dev/null 2>&1; then
        # Linux with ip command
        ip=$(ip route get 8.8.8.8 2>/dev/null | grep -oP 'src \K\S+')
    elif command -v ifconfig >/dev/null 2>&1; then
        # Linux/Unix with ifconfig
        ip=$(ifconfig 2>/dev/null | grep 'inet ' | grep -v '127.0.0.1' | head -1 | awk '{print $2}' | sed 's/addr://')
    else
        echo "Error: Cannot determine local IP address" >&2
        return 1
    fi
    
    if [ -z "$ip" ] || [ "$ip" = "127.0.0.1" ]; then
        echo "NOT_CONNECTED"
    else
        echo "$ip"
    fi
}

# Convert IP address to 32-bit integer
ip_to_int() {
    local ip="$1"
    local a b c d
    IFS='.' read -r a b c d <<< "$ip"
    echo $((a * 256 * 256 * 256 + b * 256 * 256 + c * 256 + d))
}

# Check if IP is in CIDR range using integer comparison
ip_in_cidr() {
    local ip="$1"
    local cidr="$2"

    # Validate CIDR format
    if ! validate_cidr "$cidr"; then
        return 1
    fi

    # Validate IP address
    if ! validate_ip "$ip"; then
        print_error "Error: Invalid IP address: $ip"
        return 1
    fi

    local network=$(echo "$cidr" | cut -d'/' -f1)
    local mask_bits=$(echo "$cidr" | cut -d'/' -f2)

    # Convert IP and network to integers
    local ip_int=$(ip_to_int "$ip")
    local network_int=$(ip_to_int "$network")

    # Calculate network mask
    local mask=$((0xFFFFFFFF << (32 - mask_bits)))

    # Apply mask to both IP and network
    local ip_network=$((ip_int & mask))
    local cidr_network=$((network_int & mask))

    # Check if they match
    [ "$ip_network" -eq "$cidr_network" ]
}

# Check if current IP is in home network ranges
is_home_network() {
    local current_ip="$1"
    
    # Check if IP is valid
    if [ "$current_ip" = "NOT_CONNECTED" ] || [ -z "$current_ip" ]; then
        return 1
    fi
    
    # Split HOME_NETWORK by comma and check each network
    IFS=',' read -ra networks <<< "$HOME_NETWORK"
    for network in "${networks[@]}"; do
        # Trim whitespace
        network=$(echo "$network" | xargs)
        if ip_in_cidr "$current_ip" "$network"; then
            return 0
        fi
    done
    return 1
}

# Check SSH configuration exists (single host entry)
check_ssh_config() {
    local hostname="$1"
    
    # Use ssh -G to get actual configuration (handles Include directives)
    if ! ssh -G "$hostname" >/dev/null 2>&1; then
        echo "Warning: SSH configuration for '$hostname' not found"
        return 1
    fi
    
    return 0
}

# Connect from home (regular public key authentication)
ssh_from_home() {
    local hostname="$1"
    local dry_run="${2:-false}"
    shift 2
    local ssh_options=("$@")

    print_success "Home network connection detected. Connecting with regular public key authentication..."
    print_info "Target: $hostname"

    if [ "$dry_run" = true ]; then
        if [ ${#ssh_options[@]} -gt 0 ]; then
            print_debug "[DRY RUN] Would execute: ssh ${ssh_options[*]} $hostname"
        else
            print_debug "[DRY RUN] Would execute: ssh $hostname"
        fi
        return 0
    fi

    if [ ${#ssh_options[@]} -gt 0 ]; then
        log_debug "Executing: ssh ${ssh_options[*]} $hostname"
        ssh "${ssh_options[@]}" "$hostname"
    else
        log_debug "Executing: ssh $hostname"
        ssh "$hostname"
    fi
}

# Connect from away (security key authentication)
ssh_from_away() {
    local hostname="$1"
    local dry_run="${2:-false}"
    shift 2
    local ssh_options=("$@")

    # Check if security key file exists
    if [ ! -f "$SECURITY_KEY_PATH" ]; then
        print_error "Error: Security key file not found: $SECURITY_KEY_PATH"
        echo ""
        echo "Please generate a security key first:"
        echo "  ssh-keygen -t ed25519-sk -f $SECURITY_KEY_PATH"
        echo "  ssh-keygen -t ecdsa-sk -f $SECURITY_KEY_PATH"
        echo ""
        echo "Or specify a different key using environment variable:"
        echo "  SECURITY_KEY_PATH=~/.ssh/id_ecdsa_sk smart-ssh --security-key production"
        exit 1
    fi

    print_warning "External network detected. Connecting with security key authentication..."
    print_warning "Please touch your YubiKey or security key when prompted."
    print_info "Target: $hostname (using $SECURITY_KEY_PATH)"

    # Create temporary SSH config that only uses the security key
    local temp_config
    temp_config=$(mktemp)
    trap 'rm -f "$temp_config"' RETURN

    # Check if ProxyJump is configured
    local proxy_jump
    proxy_jump=$(ssh -G "$hostname" 2>/dev/null | grep "^proxyjump " | awk '{print $2}')

    # If ProxyJump is configured, add the proxy host configuration first
    if [ -n "$proxy_jump" ] && [ "$proxy_jump" != "none" ]; then
        log_debug "ProxyJump detected: $proxy_jump"
        # Add proxy host configuration with security key
        echo "Host $proxy_jump" >> "$temp_config"
        ssh -G "$proxy_jump" 2>/dev/null | \
            grep -v "^identityfile " | \
            grep -v "^identityagent " | \
            grep -E "^(hostname|port|user) " | \
            awk '{print "    " $1 " " $2}' >> "$temp_config"
        echo "    IdentityFile $SECURITY_KEY_PATH" >> "$temp_config"
        echo "    IdentitiesOnly yes" >> "$temp_config"
        echo "    IdentityAgent none" >> "$temp_config"
        echo "" >> "$temp_config"

        # Add target host configuration (keep original IdentityFile for final destination)
        echo "Host $hostname" >> "$temp_config"
        ssh -G "$hostname" 2>/dev/null | \
            grep -v "^identityagent " | \
            grep -E "^(hostname|port|user|proxyjump|localforward|identityfile) " | \
            awk '{printf "    %s", $1; for(i=2;i<=NF;i++) printf " %s", $i; print ""}' >> "$temp_config"
        echo "    IdentitiesOnly yes" >> "$temp_config"
    else
        # No ProxyJump - direct connection with security key
        # Check if hostname references another Host alias
        local target_hostname
        target_hostname=$(ssh -G "$hostname" 2>/dev/null | grep "^hostname " | awk '{print $2}')

        # If target_hostname is a Host alias (not a FQDN/IP), resolve it
        local is_alias=false
        if [ -n "$target_hostname" ] && [ "$target_hostname" != "$hostname" ]; then
            local alias_hostname
            alias_hostname=$(ssh -G "$target_hostname" 2>/dev/null | grep "^hostname " | awk '{print $2}')
            # Check if the alias resolves to a different hostname (meaning it's a Host entry)
            if [ -n "$alias_hostname" ] && [ "$alias_hostname" != "$target_hostname" ]; then
                log_debug "HostName alias detected: $target_hostname -> $alias_hostname"
                is_alias=true
                # Add the alias host configuration
                echo "Host $target_hostname" >> "$temp_config"
                ssh -G "$target_hostname" 2>/dev/null | \
                    grep -v "^identityfile " | \
                    grep -v "^identityagent " | \
                    grep -E "^(hostname|port|user) " | \
                    awk '{print "    " $1 " " $2}' >> "$temp_config"
                echo "    IdentityFile $SECURITY_KEY_PATH" >> "$temp_config"
                echo "    IdentitiesOnly yes" >> "$temp_config"
                echo "    IdentityAgent none" >> "$temp_config"
                echo "" >> "$temp_config"
            fi
        fi

        echo "Host $hostname" >> "$temp_config"
        if [ "$is_alias" = true ]; then
            # Use settings from the alias host, plus localforward from original
            # Use the resolved hostname (FQDN/IP), not the alias
            echo "    hostname $alias_hostname" >> "$temp_config"
            ssh -G "$target_hostname" 2>/dev/null | \
                grep -v "^identityfile " | \
                grep -v "^identityagent " | \
                grep -v "^hostname " | \
                grep -E "^(port|user) " | \
                awk '{print "    " $1 " " $2}' >> "$temp_config"
            # Add localforward from original config
            ssh -G "$hostname" 2>/dev/null | \
                grep -E "^localforward " | \
                awk '{printf "    %s", $1; for(i=2;i<=NF;i++) printf " %s", $i; print ""}' >> "$temp_config"
        else
            ssh -G "$hostname" 2>/dev/null | \
                grep -v "^identityfile " | \
                grep -v "^identityagent " | \
                grep -E "^(hostname|port|user|localforward) " | \
                awk '{printf "    %s", $1; for(i=2;i<=NF;i++) printf " %s", $i; print ""}' >> "$temp_config"
        fi
        echo "    IdentityFile $SECURITY_KEY_PATH" >> "$temp_config"
        echo "    IdentitiesOnly yes" >> "$temp_config"
        echo "    IdentityAgent none" >> "$temp_config"
    fi

    if [ "$dry_run" = true ]; then
        if [ ${#ssh_options[@]} -gt 0 ]; then
            print_info "[DRY RUN] Would execute: ssh -F $temp_config ${ssh_options[*]} $hostname"
        else
            print_info "[DRY RUN] Would execute: ssh -F $temp_config $hostname"
        fi
        print_info "[DRY RUN] Temporary SSH config:"
        while IFS= read -r line; do
            print_info "  $line"
        done < "$temp_config"
        return 0
    fi

    if [ ${#ssh_options[@]} -gt 0 ]; then
        log_debug "Executing: ssh -F $temp_config ${ssh_options[*]} $hostname"
        ssh -F "$temp_config" "${ssh_options[@]}" "$hostname"
    else
        log_debug "Executing: ssh -F $temp_config $hostname"
        ssh -F "$temp_config" "$hostname"
    fi
}

# Main function
main() {
    local hostname=""
    local force_security_key=false
    local dry_run=false
    local ssh_options=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --security-key|-s)
                force_security_key=true
                shift
                ;;
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            --init-config)
                init_config
                exit $?
                ;;
            --debug|-d)
                debug_info
                exit 0
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            --)
                # End of smart-ssh options, rest are SSH options
                shift
                ssh_options+=("$@")
                break
                ;;
            -*)
                # Could be SSH option, collect it
                ssh_options+=("$1")
                shift
                ;;
            *)
                # First non-option argument is hostname
                if [ -z "$hostname" ]; then
                    hostname="$1"
                    shift
                else
                    # Additional arguments are SSH options or remote command
                    ssh_options+=("$1")
                    shift
                fi
                ;;
        esac
    done

    if [ -z "$hostname" ]; then
        print_error "Error: Please specify a hostname"
        usage
        exit 1
    fi

    # Check SSH configuration exists
    if ! check_ssh_config "$hostname"; then
        echo ""
        echo "Example SSH configuration:"
        echo "# ~/.ssh/config"
        echo "Host $hostname"
        echo "    HostName your-server.example.com"
        echo "    User your-username"
        echo "    IdentityFile ~/.ssh/id_ed25519"
        echo ""
        echo "Note: Security key ($SECURITY_KEY_PATH) will be used automatically"
        echo "      when connecting from external networks."
        exit 1
    fi

    # Force security key if requested
    if [ "$force_security_key" = true ]; then
        print_warning "Security key authentication forced by --security-key option"
        ssh_from_away "$hostname" "$dry_run" "${ssh_options[@]}"
        return
    fi

    print_info "Checking local network..."

    # Detection priority: Gateway MAC > IP address
    local is_home=false
    local detection_method=""
    local detected_value=""

    # Try Gateway MAC detection first (if configured)
    if [ -n "$HOME_GATEWAY_MAC" ]; then
        local current_mac
        current_mac=$(get_gateway_mac)
        if [ -n "$current_mac" ]; then
            log_debug "Gateway MAC: $current_mac"
            if is_home_gateway_mac "$current_mac"; then
                is_home=true
                detection_method="Gateway MAC"
                detected_value="$current_mac"
            else
                detection_method="Gateway MAC"
                detected_value="$current_mac"
            fi
        else
            log_debug "Cannot get gateway MAC, falling back to IP detection"
        fi
    fi

    # Fall back to IP-based detection
    if [ -z "$detection_method" ]; then
        CURRENT_IP=$(get_current_ip)
        log_debug "Current IP: $CURRENT_IP"

        if [ "$CURRENT_IP" = "NOT_CONNECTED" ]; then
            print_warning "Cannot determine network."

            if [ "$dry_run" = true ]; then
                print_debug "[DRY RUN] Manual selection would be required"
                print_debug "[DRY RUN] Options:"
                if [ ${#ssh_options[@]} -gt 0 ]; then
                    print_debug "  1) Regular public key: ssh ${ssh_options[*]} $hostname"
                    print_debug "  2) Security key: ssh -i $SECURITY_KEY_PATH ${ssh_options[*]} $hostname"
                else
                    print_debug "  1) Regular public key: ssh $hostname"
                    print_debug "  2) Security key: ssh -i $SECURITY_KEY_PATH $hostname"
                fi
                return 0
            fi

            echo "Please manually select SSH connection method:"
            echo "1) Regular public key authentication ($hostname)"
            echo "2) Security key authentication ($hostname using $SECURITY_KEY_PATH)"
            read -rp "Choice (1/2): " choice

            case $choice in
                1) ssh_from_home "$hostname" "$dry_run" "${ssh_options[@]}" ;;
                2) ssh_from_away "$hostname" "$dry_run" "${ssh_options[@]}" ;;
                *) print_error "Invalid choice."; exit 1 ;;
            esac
            return
        fi

        if is_home_network "$CURRENT_IP"; then
            is_home=true
        fi
        detection_method="IP"
        detected_value="$CURRENT_IP"
    fi

    # Connect based on detection result
    if [ "$is_home" = true ]; then
        print_success "Home network detected ($detection_method: $detected_value)"
        ssh_from_home "$hostname" "$dry_run" "${ssh_options[@]}"
    else
        print_warning "External network detected ($detection_method: $detected_value)"
        ssh_from_away "$hostname" "$dry_run" "${ssh_options[@]}"
    fi
}

# Show debug information
debug_info() {
    echo "=== Debug Information ==="
    echo ""
    echo "Configuration:"
    echo "  Config file: $CONFIG_FILE"
    echo "  Config file exists: $([ -f "$CONFIG_FILE" ] && echo "Yes" || echo "No")"
    echo "  HOME_GATEWAY_MAC: ${HOME_GATEWAY_MAC:-<not configured>}"
    echo "  HOME_NETWORK: $HOME_NETWORK"
    echo "  SECURITY_KEY_PATH: $SECURITY_KEY_PATH"
    echo "  LOG_LEVEL: $LOG_LEVEL"
    echo ""
    echo "Network:"
    echo "  Gateway IP: $(get_gateway_ip)"
    echo "  Gateway MAC: $(get_gateway_mac || echo 'N/A')"
    echo "  Current IP: $(get_current_ip)"
    echo "  Security key file exists: $([ -f "$SECURITY_KEY_PATH" ] && echo "Yes" || echo "No")"
    echo ""
    echo "Network connection status:"
    
    # Show platform-specific network info
    if grep -qi "microsoft.*wsl\|wsl.*microsoft" /proc/version 2>/dev/null || command -v powershell.exe >/dev/null 2>&1; then
        echo "WSL2 detected - showing Windows host network info:"
        powershell.exe -Command "Get-NetAdapter | Where-Object {\$_.Status -eq 'Up'} | Select-Object Name,InterfaceDescription" 2>/dev/null
        powershell.exe -Command "Get-NetIPAddress -AddressFamily IPv4 | Where-Object {\$_.InterfaceAlias -like '*Wi-Fi*'} | Select-Object IPAddress,InterfaceAlias" 2>/dev/null
    elif command -v ip >/dev/null 2>&1; then
        ip addr show | grep -E "(inet |UP,)"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        ifconfig | grep -E "(flags=|inet )" | grep -A1 "UP," | grep "inet "
    fi
    
    echo ""
    echo "SSH configuration check:"
    if [ -f ~/.ssh/config ]; then
        echo "~/.ssh/config exists"
        echo "Available host entries (including Include directives):"

        # Parse SSH config including Include directives (same logic as completions)
        awk '
            /^Include / {
                # Expand ~ to HOME directory
                include_path = $2
                gsub(/^~/, ENVIRON["HOME"], include_path)
                # Handle glob patterns
                cmd = "ls -1 " include_path " 2>/dev/null"
                while ((cmd | getline file) > 0) {
                    while ((getline line < file) > 0) {
                        if (line ~ /^Host /) {
                            split(line, parts)
                            for (i = 2; i <= length(parts); i++) {
                                print parts[i]
                            }
                        }
                    }
                    close(file)
                }
                close(cmd)
            }
            /^Host / {
                for (i = 2; i <= NF; i++) {
                    print $i
                }
            }
        ' ~/.ssh/config 2>/dev/null | grep -v "[*?!]" | sort -u | head -20 || echo "  No Host entries found"
    else
        echo "~/.ssh/config does not exist"
    fi
    echo "========================="
}

# Handle options and arguments
case "$1" in
    --debug|-d)
        debug_info
        ;;
    --help|-h|"")
        usage
        ;;
    *)
        main "$@"
        ;;
esac
